diff --git a/src/column/column.rs b/src/column/column.rs
index b5c26af..cdeb54a 100644
--- a/src/column/column.rs
+++ b/src/column/column.rs
@@ -82,6 +82,37 @@ impl<'a> ColumnWrapper<'a> {
         }
     }
 
+    /*
+        pub(crate) fn new<T>(s: &'a [T]) -> Self
+    where
+        T: 'static + Sync,
+    {
+        SliceRef {
+            type_id: std::any::TypeId::of::<[T]>(),
+            len: s.len(),
+            ptr: s.as_ptr() as *const u8,
+            phantom: PhantomData,
+        }
+    }
+    */
+    pub fn new_slice<T>(col: &'a [T], index: Option<Vec<usize>>, bitmap: Option<Bitmap>) -> Self
+    where
+        T: 'static + Sync,
+    {
+        //Validate that the bitmap and the data have the same length
+
+        let typeid = TypeId::of::<[T]>();
+        let typename = std::any::type_name::<[T]>();
+        Self {
+            column: ColumnData::SliceRef(SliceRef::new::<T>(col)),
+            index,
+            bitmap,
+            typeid,
+            typename: typename.to_string(),
+            name: None,
+        }
+    }
+
     pub fn new_ref_mut<T, V>(
         col: &'a mut V,
         index: Option<Vec<usize>>,
@@ -108,6 +139,28 @@ impl<'a> ColumnWrapper<'a> {
         }
     }
 
+    pub fn new_slice_mut<T>(
+        col: &'a mut [T],
+        index: Option<Vec<usize>>,
+        bitmap: Option<Bitmap>,
+    ) -> Self
+    where
+        T: 'static + Sync,
+    {
+        //Validate that the bitmap and the data have the same length
+
+        let typeid = TypeId::of::<[T]>();
+        let typename = std::any::type_name::<[T]>();
+        Self {
+            column: ColumnData::SliceRefMut(SliceRefMut::new::<T>(col)),
+            index,
+            bitmap,
+            typeid,
+            typename: typename.to_string(),
+            name: None,
+        }
+    }
+
     pub fn new_ref_u8(
         col: &'a ColumnU8,
         index: Option<Vec<usize>>,
@@ -217,7 +270,7 @@ impl<'a> ColumnWrapper<'a> {
         &self,
     ) -> &[<V as SliceMarker<V>>::Element]
     where
-        <V as SliceMarker<V>>::Element: 'static,
+        <V as SliceMarker<V>>::Element: 'static + Sync,
     {
         let (typename, col) = (&self.typename, &self.column);
         let col_ref_downcasted = match col {
@@ -239,7 +292,7 @@ impl<'a> ColumnWrapper<'a> {
         &mut self,
     ) -> &mut [<V as SliceMarker<V>>::Element]
     where
-        <V as SliceMarker<V>>::Element: 'static,
+        <V as SliceMarker<V>>::Element: 'static + Sync,
     {
         let (typename, col) = (&mut self.typename, &mut self.column);
         let col_ref_downcasted = match  col {
@@ -264,7 +317,7 @@ impl<'a> ColumnWrapper<'a> {
         &mut Option<Bitmap>,
     )
     where
-        <V as SliceMarker<V>>::Element: 'static,
+        <V as SliceMarker<V>>::Element: 'static + Sync,
     {
         let (col, ind, bmap, typename, _typeid) = (
             &mut self.column,
diff --git a/src/column/sliceref.rs b/src/column/sliceref.rs
index a590ce4..db38391 100644
--- a/src/column/sliceref.rs
+++ b/src/column/sliceref.rs
@@ -8,18 +8,18 @@ pub(crate) struct SliceRef<'a> {
     phantom: std::marker::PhantomData<&'a u8>,
 }
 
-pub trait SliceMarker<V: ?Sized> {
+pub unsafe trait SliceMarker<V: ?Sized> {
     type Element;
 }
 
-impl<T: 'static> SliceMarker<[T]> for [T] {
+unsafe impl<T: 'static + Sync> SliceMarker<[T]> for [T] {
     type Element = T;
 }
 
 impl<'a> SliceRef<'a> {
     pub(crate) fn new<T>(s: &'a [T]) -> Self
     where
-        T: 'static,
+        T: 'static + Sync,
     {
         SliceRef {
             type_id: std::any::TypeId::of::<[T]>(),
@@ -30,7 +30,7 @@ impl<'a> SliceRef<'a> {
     }
     pub(crate) fn is<V: SliceMarker<V> + ?Sized>(&self) -> bool
     where
-        <V as SliceMarker<V>>::Element: 'static,
+        <V as SliceMarker<V>>::Element: 'static + Sync,
     {
         // Get `TypeId` of the type this function is instantiated with.
         let t = std::any::TypeId::of::<[<V as SliceMarker<V>>::Element]>();
@@ -45,7 +45,7 @@ impl<'a> SliceRef<'a> {
         &self,
     ) -> Option<&[<V as SliceMarker<V>>::Element]>
     where
-        <V as SliceMarker<V>>::Element: 'static,
+        <V as SliceMarker<V>>::Element: 'static + Sync,
     {
         if self.is::<V>() {
             let ptr = self.ptr;
@@ -77,7 +77,7 @@ pub(crate) struct SliceRefMut<'a> {
 impl<'a> SliceRefMut<'a> {
     pub(crate) fn new<T>(s: &'a mut [T]) -> Self
     where
-        T: 'static,
+        T: 'static + Sync,
     {
         SliceRefMut {
             type_id: std::any::TypeId::of::<[T]>(),
@@ -88,7 +88,7 @@ impl<'a> SliceRefMut<'a> {
     }
     pub(crate) fn is<V: SliceMarker<V> + ?Sized>(&self) -> bool
     where
-        <V as SliceMarker<V>>::Element: 'static,
+        <V as SliceMarker<V>>::Element: 'static + Sync,
     {
         // Get `TypeId` of the type this function is instantiated with.
         let t = std::any::TypeId::of::<[<V as SliceMarker<V>>::Element]>();
@@ -103,7 +103,7 @@ impl<'a> SliceRefMut<'a> {
         &mut self,
     ) -> Option<&mut [<V as SliceMarker<V>>::Element]>
     where
-        <V as SliceMarker<V>>::Element: 'static,
+        <V as SliceMarker<V>>::Element: 'static + Sync,
     {
         if self.is::<V>() {
             let ptr = self.ptr;
@@ -123,7 +123,7 @@ impl<'a> SliceRefMut<'a> {
         &self,
     ) -> Option<&[<V as SliceMarker<V>>::Element]>
     where
-        <V as SliceMarker<V>>::Element: 'static,
+        <V as SliceMarker<V>>::Element: 'static + Sync,
     {
         if self.is::<V>() {
             let ptr = self.ptr;
diff --git a/src/expressions/opdictionary.rs b/src/expressions/opdictionary.rs
index 55f73aa..366f659 100644
--- a/src/expressions/opdictionary.rs
+++ b/src/expressions/opdictionary.rs
@@ -56,7 +56,7 @@ impl Signature {
         }
     }
 
-    pub fn add_input<T: 'static>(&mut self) {
+    pub fn add_input<T: 'static + ?Sized>(&mut self) {
         self.input.push(TypeId::of::<T>());
         self.input_typenames
             .push(std::any::type_name::<T>().to_string());
diff --git a/src/expressions/operations/addassign.rs b/src/expressions/operations/addassign.rs
index 88e953a..fd98445 100644
--- a/src/expressions/operations/addassign.rs
+++ b/src/expressions/operations/addassign.rs
@@ -19,11 +19,18 @@ macro_rules! operation_load {
                 output_typename: std::any::type_name::<Vec<$tl>>().to_string()
             };
             $dict.insert(signature, op);
-            let signature=sig![OP; Box<[$tl]>, Box<[$tr]>];
+            let signature=sig![OP; [$tl], [$tr]];
             let op=Operation{
-                f:  paste!{[<addassign_boxslice $tl:lower _ boxslice $tr:lower>]},
-                output_type: std::any::TypeId::of::<Box<[$tl]>>(),
-                output_typename: std::any::type_name::<Box<[$tl]>>().to_string()
+                f:  paste!{[<addassign_slice $tl:lower _ slice $tr:lower>]},
+                output_type: std::any::TypeId::of::<[$tl]>(),
+                output_typename: std::any::type_name::<[$tl]>().to_string()
+            };
+            $dict.insert(signature, op);
+            let signature=sig![OP; Vec<$tl>, [$tr]];
+            let op=Operation{
+                f:  paste!{[<addassign_vec $tl:lower _ slice $tr:lower>]},
+                output_type: std::any::TypeId::of::<Vec<$tl>>(),
+                output_typename: std::any::type_name::<[$tl]>().to_string()
             };
             $dict.insert(signature, op);
     )+)
@@ -35,11 +42,70 @@ macro_rules! operation_impl {
         paste!   {
             fn [<addassign_vec $tl:lower _ vec $tr:lower>](output: &mut ColumnWrapper, input: Vec<InputTypes>)
             {
-                addassign_c::<Vec<$tl>, Vec<$tr>, $tl, $tr>(output, input);
+                type V1=$tl;
+                type V2=$tr;
+
+                let (data_output, index_output, bitmap_output) = output.all_mut::<Vec<V1>>();
+
+                let (data_input, index_input, bitmap_input) = match &input[0] {
+                    InputTypes::Ref(a) => (
+                        a.downcast_ref::<Vec<V2>>(),
+                        a.index(),
+                        a.bitmap(),
+                    ),
+                    InputTypes::Owned(a) => (
+                        a.downcast_ref::<Vec<V2>>(),
+                        a.index(),
+                        a.bitmap(),
+                    ),
+                };
+                addassign_c(data_output, index_output,bitmap_output, data_input, index_input, bitmap_input);
+
+
+            }
+            fn [<addassign_slice $tl:lower _ slice $tr:lower>](output: &mut ColumnWrapper, input: Vec<InputTypes>)
+            {
+                type V1=$tl;
+                type V2=$tr;
+
+                let (data_output, index_output, bitmap_output) = output.slice_all_mut::<[$tl]>();
+
+                let (data_input, index_input, bitmap_input) = match &input[0] {
+                    InputTypes::Ref(a) => (
+                        a.downcast_slice_ref::<[$tr]>(),
+                        a.index(),
+                        a.bitmap(),
+                    ),
+                    InputTypes::Owned(a) => (
+                        a.downcast_slice_ref::<[$tr]>(),
+                        a.index(),
+                        a.bitmap(),
+                    ),
+                };
+                addassign_c(data_output, index_output,bitmap_output, data_input, index_input, bitmap_input);
+
             }
-            fn [<addassign_boxslice $tl:lower _ boxslice $tr:lower>](output: &mut ColumnWrapper, input: Vec<InputTypes>)
+            fn [<addassign_vec $tl:lower _ slice $tr:lower>](output: &mut ColumnWrapper, input: Vec<InputTypes>)
             {
-                addassign_c::<Box<[$tl]>, Box<[$tr]>, $tl, $tr>(output, input);
+                type V1=$tl;
+                type V2=$tr;
+
+                let (data_output, index_output, bitmap_output) = output.all_mut::<Vec<$tl>>();
+
+                let (data_input, index_input, bitmap_input) = match &input[0] {
+                    InputTypes::Ref(a) => (
+                        a.downcast_slice_ref::<[$tr]>(),
+                        a.index(),
+                        a.bitmap(),
+                    ),
+                    InputTypes::Owned(a) => (
+                        a.downcast_slice_ref::<[$tr]>(),
+                        a.index(),
+                        a.bitmap(),
+                    ),
+                };
+                addassign_c(data_output, index_output,bitmap_output, data_input, index_input, bitmap_input);
+
             }
         }
     )+)
@@ -55,10 +121,14 @@ pub(crate) fn load_op_dict(dict: &mut OpDictionary) {
     };
 }
 
-fn addassign_c<V1, V2, T1, T2>(output: &mut ColumnWrapper, input: Vec<InputTypes>)
-where
-    V1: DerefMut<Target = [T1]> + 'static,
-    V2: Deref<Target = [T2]> + 'static,
+fn addassign_c<T1, T2>(
+    data_output: &mut [T1],
+    index_output: &mut ColumnIndex,
+    bitmap_output: &mut Option<Bitmap>,
+    data_input: &[T2],
+    index_input: &ColumnIndex,
+    bitmap_input: &Option<Bitmap>,
+) where
     T1: AddAssign,
     T1: From<T2>,
     T1: Default,
@@ -69,21 +139,6 @@ where
     //right[0]-->input
     //if right[0] and right[1]-> input_lhs, input_rhs
 
-    let (data_output, index_output, bitmap_output) = output.all_mut::<V1>();
-
-    let (data_input, index_input, bitmap_input) = match &input[0] {
-        InputTypes::Ref(a) => (
-            a.downcast_ref::<V2>(),
-            a.index().as_ref(),
-            a.bitmap().as_ref(),
-        ),
-        InputTypes::Owned(a) => (
-            a.downcast_ref::<V2>(),
-            a.index().as_ref(),
-            a.bitmap().as_ref(),
-        ),
-    };
-
     //The output column should have no index
     assert_eq!(index_output, &None);
 
diff --git a/src/lib.rs b/src/lib.rs
index 5b0a806..989b46e 100644
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -952,7 +952,7 @@ mod tests {
 
         let s1 = sig!["+"; Vec<u32>, Vec<u32>];
         let s2 = sig!["+"; Vec<u64>, Vec<u32>];
-        let s3 = sig!["+="; Vec<u64>,Vec<u64>];
+        let s3 = sig!["+="; Vec<u64>,[u64]];
 
         let col1: Vec<ColumnWrapper> = vec![
             //let col1: Vec<Arc<OwnedColumn<Vec<u64>>>> = vec![
@@ -978,11 +978,15 @@ mod tests {
             ColumnWrapper::new(vec![0_u64, 0, 0], None, None),
         ];
 
+        let col4: Vec<u64> = vec![4, 5, 6, 4, 5, 6, 4, 5, 6];
+
+        /*
         let col4: Vec<ColumnWrapper> = vec![
             ColumnWrapper::new(vec![4_u64, 5, 6], None, None),
             ColumnWrapper::new(vec![4_u64, 5, 6], None, None),
             ColumnWrapper::new(vec![4_u64, 5, 6], None, None),
         ];
+        */
 
         let expr: Expression = Expression::new(
             s1,
@@ -1008,15 +1012,17 @@ mod tests {
             .iter()
             .zip(col2.iter())
             .zip(col3.iter())
-            .zip(col4.iter())
+            .zip(col4.chunks(3))
             .map(|(((c1, c2), c3), c4)| {
                 let (_, mut owned_values) = expr.compile(&dict, &init_dict);
 
                 let mut owned_values_refmut = owned_values.iter_mut().collect();
 
+                let c4_slice = ColumnWrapper::new_slice(c4, None, None);
+
                 expr.eval(
                     &mut owned_values_refmut,
-                    &vec![c1, c2, c3, c4],
+                    &vec![c1, c2, c3, &c4_slice],
                     &vec![],
                     &dict,
                 );
@@ -1175,6 +1181,7 @@ mod tests {
         let (l, r) = t.split_at_mut(3);
         let mut srm = SliceRefMut::new(l);
         let a = srm.downcast_mut::<[u64]>().unwrap();
+
         a[1] = 7;
         drop(a);
         l[0] = 6;
