git am -3 -k file.patch





From 99ac7e04483e4fcf888582a6a2084fa27e77e542 Mon Sep 17 00:00:00 2001
From: 
Date: Tue, 22 Sep 2020 09:19:01 +0200
Subject: implementation of SliceRef - first step for support of ColumnWrapper
 over slices

---
 src/column/column.rs   |  81 ++++++++++++++++++++++-
 src/column/mod.rs      |   2 +
 src/column/sliceref.rs | 142 +++++++++++++++++++++++++++++++++++++++++
 src/lib.rs             |  73 ++-------------------
 4 files changed, 231 insertions(+), 67 deletions(-)
 create mode 100644 src/column/sliceref.rs

diff --git a/src/column/column.rs b/src/column/column.rs
index 183e493..b5c26af 100644
--- a/src/column/column.rs
+++ b/src/column/column.rs
@@ -1,4 +1,4 @@
-use crate::{bitmap::*, ColumnIndex, ColumnU8};
+use crate::{bitmap::*, ColumnIndex, ColumnU8, SliceMarker, SliceRef, SliceRefMut};
 use core::any::Any;
 use std::{any::TypeId, ops::Deref};
 
@@ -24,6 +24,8 @@ pub(crate) enum ColumnData<'a> {
     Ref(&'a (dyn Any + Send + Sync)),
     RefMut(&'a mut (dyn Any + Send + Sync)),
     Owned(Box<dyn Any + Send + Sync>),
+    SliceRef(SliceRef<'a>),
+    SliceRefMut(SliceRefMut<'a>),
 }
 
 #[derive(Debug)]
@@ -199,6 +201,7 @@ impl<'a> ColumnWrapper<'a> {
             ColumnData::Ref(col) => &(**col),
             ColumnData::RefMut(col) => &(**col),
             ColumnData::Owned(col) => &(**col),
+            _=>panic!("downcast_ref can only be used with Ref, RefMut, and Owned variants of ColumnWrapper")
         };
 
         col_ref.downcast_ref::<V>().unwrap_or_else(|| {
@@ -210,6 +213,82 @@ impl<'a> ColumnWrapper<'a> {
         })
     }
 
+    pub fn downcast_slice_ref<V: SliceMarker<V> + ?Sized>(
+        &self,
+    ) -> &[<V as SliceMarker<V>>::Element]
+    where
+        <V as SliceMarker<V>>::Element: 'static,
+    {
+        let (typename, col) = (&self.typename, &self.column);
+        let col_ref_downcasted = match col {
+            ColumnData::SliceRef(col) => col.downcast_ref::<V>(),
+            ColumnData::SliceRefMut(col) => col.downcast_ref::<V>(),
+            _=>panic!("downcast_slice_ref can only be used with SliceRef and SliceRefMut variants of ColumnWrapper")
+        };
+
+        col_ref_downcasted.unwrap_or_else(|| {
+            panic!(
+                "Slice downcast failed. Source type is {}, target type is {}",
+                typename,
+                std::any::type_name::<[<V as SliceMarker<V>>::Element]>()
+            )
+        })
+    }
+
+    pub fn downcast_slice_mut<V: SliceMarker<V> + ?Sized>(
+        &mut self,
+    ) -> &mut [<V as SliceMarker<V>>::Element]
+    where
+        <V as SliceMarker<V>>::Element: 'static,
+    {
+        let (typename, col) = (&mut self.typename, &mut self.column);
+        let col_ref_downcasted = match  col {
+            ColumnData::SliceRefMut(col) => col.downcast_mut::<V>(),
+            _=>panic!("downcast_slice_ref can only be used with SliceRef and SliceRefMut variants of ColumnWrapper")
+        };
+
+        col_ref_downcasted.unwrap_or_else(|| {
+            panic!(
+                "Slice downcast failed. Source type is {}, target type is {}",
+                typename,
+                std::any::type_name::<[<V as SliceMarker<V>>::Element]>()
+            )
+        })
+    }
+
+    pub fn slice_all_mut<V: SliceMarker<V> + ?Sized>(
+        &mut self,
+    ) -> (
+        &mut [<V as SliceMarker<V>>::Element],
+        &mut Option<Vec<usize>>,
+        &mut Option<Bitmap>,
+    )
+    where
+        <V as SliceMarker<V>>::Element: 'static,
+    {
+        let (col, ind, bmap, typename, _typeid) = (
+            &mut self.column,
+            &mut self.index,
+            &mut self.bitmap,
+            &self.typename,
+            &self.typeid,
+        );
+
+        let col_ref_downcasted = match col {
+            ColumnData::SliceRefMut(col) => col.downcast_mut::<V>(),
+            _=>panic!("downcast_slice_ref can only be used with SliceRef and SliceRefMut variants of ColumnWrapper")
+        };
+
+        let col = col_ref_downcasted.unwrap_or_else(|| {
+            panic!(
+                "Slice downcast failed. Source type is {}, target type is {}",
+                typename,
+                std::any::type_name::<[<V as SliceMarker<V>>::Element]>(),
+            )
+        });
+        (col, ind, bmap)
+    }
+
     pub fn index(&self) -> &Option<Vec<usize>> {
         &self.index
     }
diff --git a/src/column/mod.rs b/src/column/mod.rs
index b9471f6..f77c87b 100644
--- a/src/column/mod.rs
+++ b/src/column/mod.rs
@@ -1,5 +1,7 @@
 pub mod column;
 pub mod hashcolumn;
+pub(crate) mod sliceref;
 
 pub use column::*;
 pub use hashcolumn::*;
+pub(crate) use sliceref::*;
diff --git a/src/column/sliceref.rs b/src/column/sliceref.rs
new file mode 100644
index 0000000..a590ce4
--- /dev/null
+++ b/src/column/sliceref.rs
@@ -0,0 +1,142 @@
+use std::marker::PhantomData;
+
+#[derive(Debug)]
+pub(crate) struct SliceRef<'a> {
+    type_id: std::any::TypeId,
+    len: usize,
+    ptr: *const u8,
+    phantom: std::marker::PhantomData<&'a u8>,
+}
+
+pub trait SliceMarker<V: ?Sized> {
+    type Element;
+}
+
+impl<T: 'static> SliceMarker<[T]> for [T] {
+    type Element = T;
+}
+
+impl<'a> SliceRef<'a> {
+    pub(crate) fn new<T>(s: &'a [T]) -> Self
+    where
+        T: 'static,
+    {
+        SliceRef {
+            type_id: std::any::TypeId::of::<[T]>(),
+            len: s.len(),
+            ptr: s.as_ptr() as *const u8,
+            phantom: PhantomData,
+        }
+    }
+    pub(crate) fn is<V: SliceMarker<V> + ?Sized>(&self) -> bool
+    where
+        <V as SliceMarker<V>>::Element: 'static,
+    {
+        // Get `TypeId` of the type this function is instantiated with.
+        let t = std::any::TypeId::of::<[<V as SliceMarker<V>>::Element]>();
+
+        // Get `TypeId` of the type in the trait object (`self`).
+        let concrete = self.type_id;
+
+        // Compare both `TypeId`s on equality.
+        t == concrete
+    }
+    pub(crate) fn downcast_ref<V: SliceMarker<V> + ?Sized>(
+        &self,
+    ) -> Option<&[<V as SliceMarker<V>>::Element]>
+    where
+        <V as SliceMarker<V>>::Element: 'static,
+    {
+        if self.is::<V>() {
+            let ptr = self.ptr;
+            let len = self.len;
+            // SAFETY: just checked whether we are pointing to the correct type, and we can rely on
+            // that check for memory safety because we have implemented Any for all types; no other
+            // impls can exist as they would conflict with our impl.
+            unsafe {
+                let ptr = ptr as *const <V as SliceMarker<V>>::Element;
+                Some(std::slice::from_raw_parts(ptr, len))
+            }
+        } else {
+            None
+        }
+    }
+}
+
+unsafe impl<'a> Sync for SliceRef<'a> {}
+unsafe impl<'a> Sync for SliceRefMut<'a> {}
+
+#[derive(Debug)]
+pub(crate) struct SliceRefMut<'a> {
+    type_id: std::any::TypeId,
+    len: usize,
+    ptr: *mut u8,
+    phantom: std::marker::PhantomData<&'a u8>,
+}
+
+impl<'a> SliceRefMut<'a> {
+    pub(crate) fn new<T>(s: &'a mut [T]) -> Self
+    where
+        T: 'static,
+    {
+        SliceRefMut {
+            type_id: std::any::TypeId::of::<[T]>(),
+            len: s.len(),
+            ptr: s.as_mut_ptr() as *mut u8,
+            phantom: PhantomData,
+        }
+    }
+    pub(crate) fn is<V: SliceMarker<V> + ?Sized>(&self) -> bool
+    where
+        <V as SliceMarker<V>>::Element: 'static,
+    {
+        // Get `TypeId` of the type this function is instantiated with.
+        let t = std::any::TypeId::of::<[<V as SliceMarker<V>>::Element]>();
+
+        // Get `TypeId` of the type in the trait object (`self`).
+        let concrete = self.type_id;
+
+        // Compare both `TypeId`s on equality.
+        t == concrete
+    }
+    pub(crate) fn downcast_mut<V: SliceMarker<V> + ?Sized>(
+        &mut self,
+    ) -> Option<&mut [<V as SliceMarker<V>>::Element]>
+    where
+        <V as SliceMarker<V>>::Element: 'static,
+    {
+        if self.is::<V>() {
+            let ptr = self.ptr;
+            let len = self.len;
+            // SAFETY: just checked whether we are pointing to the correct type, and we can rely on
+            // that check for memory safety because we have implemented Any for all types; no other
+            // impls can exist as they would conflict with our impl.
+            unsafe {
+                let ptr = ptr as *mut <V as SliceMarker<V>>::Element;
+                Some(std::slice::from_raw_parts_mut(ptr, len))
+            }
+        } else {
+            None
+        }
+    }
+    pub(crate) fn downcast_ref<V: SliceMarker<V> + ?Sized>(
+        &self,
+    ) -> Option<&[<V as SliceMarker<V>>::Element]>
+    where
+        <V as SliceMarker<V>>::Element: 'static,
+    {
+        if self.is::<V>() {
+            let ptr = self.ptr;
+            let len = self.len;
+            // SAFETY: just checked whether we are pointing to the correct type, and we can rely on
+            // that check for memory safety because we have implemented Any for all types; no other
+            // impls can exist as they would conflict with our impl.
+            unsafe {
+                let ptr = ptr as *const <V as SliceMarker<V>>::Element;
+                Some(std::slice::from_raw_parts(ptr, len))
+            }
+        } else {
+            None
+        }
+    }
+}
diff --git a/src/lib.rs b/src/lib.rs
index 608e1bd..5b0a806 100644
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -1128,72 +1128,6 @@ mod tests {
                RefMut(&'a mut (dyn Any + Send + Sync)),
         */
 
-        trait SliceAny {
-            fn type_id(&self) -> std::any::TypeId;
-            fn len(&self) -> usize;
-            fn as_slice_ptr(&self) -> *const u8;
-            fn as_slice_mut_ptr(&mut self) -> *mut u8;
-        }
-
-        impl<T: 'static> SliceAny for [T] {
-            fn type_id(&self) -> std::any::TypeId {
-                std::any::TypeId::of::<T>()
-            }
-            fn len(&self) -> usize {
-                self.len()
-            }
-            fn as_slice_ptr(&self) -> *const u8 {
-                self.as_ptr() as *const u8
-            }
-            fn as_slice_mut_ptr(&mut self) -> *mut u8 {
-                self.as_mut_ptr() as *mut u8
-            }
-        }
-
-        impl dyn SliceAny {
-            pub fn is<T: std::any::Any>(&self) -> bool {
-                // Get `TypeId` of the type this function is instantiated with.
-                let t = std::any::TypeId::of::<T>();
-
-                // Get `TypeId` of the type in the trait object (`self`).
-                let concrete = self.type_id();
-
-                // Compare both `TypeId`s on equality.
-                t == concrete
-            }
-            pub fn downcast_ref<T: std::any::Any>(&self) -> Option<&[T]> {
-                if self.is::<T>() {
-                    let ptr = self.as_slice_ptr();
-                    let len = self.len();
-                    // SAFETY: just checked whether we are pointing to the correct type, and we can rely on
-                    // that check for memory safety because we have implemented Any for all types; no other
-                    // impls can exist as they would conflict with our impl.
-                    unsafe {
-                        let ptr = ptr as *const T;
-                        Some(std::slice::from_raw_parts(ptr, len))
-                    }
-                } else {
-                    None
-                }
-            }
-
-            pub fn downcast_mut<T: std::any::Any>(&mut self) -> Option<&mut [T]> {
-                if self.is::<T>() {
-                    let ptr = self.as_slice_mut_ptr();
-                    let len = self.len();
-                    // SAFETY: just checked whether we are pointing to the correct type, and we can rely on
-                    // that check for memory safety because we have implemented Any for all types; no other
-                    // impls can exist as they would conflict with our impl.
-                    unsafe {
-                        let ptr = ptr as *mut T;
-                        Some(std::slice::from_raw_parts_mut(ptr, len))
-                    }
-                } else {
-                    None
-                }
-            }
-        }
-
         let mut dict: OpDictionary = HashMap::new();
         load_op_dict(&mut dict);
         let mut init_dict: InitDictionary = HashMap::new();
@@ -1239,6 +1173,13 @@ mod tests {
         assert_eq!(c2.index(), &c2_index_orig);
         let mut t: Vec<u64> = vec![1, 2, 3, 4, 5];
         let (l, r) = t.split_at_mut(3);
+        let mut srm = SliceRefMut::new(l);
+        let a = srm.downcast_mut::<[u64]>().unwrap();
+        a[1] = 7;
+        drop(a);
+        l[0] = 6;
+        drop(l);
+        t.iter().for_each(|i| println!("{}", i));
         //let v = unsafe { slice_to_vec(l) };
     }
 }
-- 
2.23.3

