diff --git a/src/bucketcolumn.rs b/src/bucketcolumn.rs
--- a/src/bucketcolumn.rs
+++ b/src/bucketcolumn.rs
@@ -3,22 +3,22 @@ use std::ops::Deref;

 use crate::hashcolumn::*;

-pub struct BucketColumn {
+pub struct BucketColumn<'a> {
     //TO-DO: Implement Drop in parallel
     //TO-DO: Make data Vec<Vec<usize>> and move worker count
     pub(crate) data: Vec<usize>,
     pub(crate) buckets_count: usize,
-    pub(crate) hash: HashColumn,
+    pub(crate) hash: HashColumn<'a>,
 }

-impl Deref for BucketColumn {
+impl<'a> Deref for BucketColumn<'a> {
     type Target = Vec<usize>;
     fn deref(&self) -> &Self::Target {
         &self.data
     }
 }

-impl BucketColumn {
+impl<'a> BucketColumn<'a> {
     pub fn from_hash(hash: HashColumn, bucket_bits: u32) -> BucketColumn {
         let buckets_count = 2usize.pow(bucket_bits);
         assert!(
@@ -71,7 +71,7 @@ impl BucketColumnPartitioned {
     }
 }

-pub struct BucketsSizeMap {
+pub struct BucketsSizeMap<'a> {
     //TO-DO: Implement Drop in parallel
     pub(crate) data: Vec<Vec<usize>>, //workers_count x bucket_count
     pub(crate) workers_count: usize,
@@ -80,18 +80,18 @@ pub struct BucketsSizeMap {
     pub(crate) bucket_column: Vec<usize>,
     pub(crate) offsets: Vec<Vec<usize>>,
     pub(crate) bucket_sizes: Vec<usize>,
-    pub(crate) hash: HashColumn,
+    pub(crate) hash: HashColumn<'a>,
 }

-impl Deref for BucketsSizeMap {
+impl<'a> Deref for BucketsSizeMap<'a> {
     type Target = Vec<Vec<usize>>;
     fn deref(&self) -> &Self::Target {
         &self.data
     }
 }

-impl BucketsSizeMap {
-    pub fn from_bucket_column(bc: BucketColumn, workers_count: usize) -> Self {
+impl<'a> BucketsSizeMap<'a> {
+    pub fn from_bucket_column(bc: BucketColumn<'a>, workers_count: usize) -> Self {
         let chunk_len = (bc.len() + workers_count - 1) / workers_count;
         let bmap: Vec<Vec<usize>> = bc
             .par_chunks(chunk_len)
diff --git a/src/column/column.rs b/src/column/column.rs
index 61b82aa..183e493 100644
--- a/src/column/column.rs
+++ b/src/column/column.rs
@@ -1,4 +1,4 @@
-use crate::{bitmap::*, ColumnIndex};
+use crate::{bitmap::*, ColumnIndex, ColumnU8};
 use core::any::Any;

[ec2-user@ip-10-223-224-245 radix]$ ls
benches  Cargo.lock  Cargo.toml  LICENSE  README.md  src  target
[ec2-user@ip-10-223-224-245 radix]$ git diff > diff.txt
[ec2-user@ip-10-223-224-245 radix]$ cat diff.txt
diff --git a/src/bucketcolumn.rs b/src/bucketcolumn.rs
index 46fd63a..4313d3e 100644
--- a/src/bucketcolumn.rs
+++ b/src/bucketcolumn.rs
@@ -3,22 +3,22 @@ use std::ops::Deref;

 use crate::hashcolumn::*;

-pub struct BucketColumn {
+pub struct BucketColumn<'a> {
     //TO-DO: Implement Drop in parallel
     //TO-DO: Make data Vec<Vec<usize>> and move worker count
     pub(crate) data: Vec<usize>,
     pub(crate) buckets_count: usize,
-    pub(crate) hash: HashColumn,
+    pub(crate) hash: HashColumn<'a>,
 }

-impl Deref for BucketColumn {
+impl<'a> Deref for BucketColumn<'a> {
     type Target = Vec<usize>;
     fn deref(&self) -> &Self::Target {
         &self.data
     }
 }

-impl BucketColumn {
+impl<'a> BucketColumn<'a> {
     pub fn from_hash(hash: HashColumn, bucket_bits: u32) -> BucketColumn {
         let buckets_count = 2usize.pow(bucket_bits);
         assert!(
@@ -71,7 +71,7 @@ impl BucketColumnPartitioned {
     }
 }

-pub struct BucketsSizeMap {
+pub struct BucketsSizeMap<'a> {
     //TO-DO: Implement Drop in parallel
     pub(crate) data: Vec<Vec<usize>>, //workers_count x bucket_count
     pub(crate) workers_count: usize,
@@ -80,18 +80,18 @@ pub struct BucketsSizeMap {
     pub(crate) bucket_column: Vec<usize>,
     pub(crate) offsets: Vec<Vec<usize>>,
     pub(crate) bucket_sizes: Vec<usize>,
-    pub(crate) hash: HashColumn,
+    pub(crate) hash: HashColumn<'a>,
 }

-impl Deref for BucketsSizeMap {
+impl<'a> Deref for BucketsSizeMap<'a> {
     type Target = Vec<Vec<usize>>;
     fn deref(&self) -> &Self::Target {
         &self.data
     }
 }

-impl BucketsSizeMap {
-    pub fn from_bucket_column(bc: BucketColumn, workers_count: usize) -> Self {
+impl<'a> BucketsSizeMap<'a> {
+    pub fn from_bucket_column(bc: BucketColumn<'a>, workers_count: usize) -> Self {
         let chunk_len = (bc.len() + workers_count - 1) / workers_count;
         let bmap: Vec<Vec<usize>> = bc
             .par_chunks(chunk_len)
diff --git a/src/column/column.rs b/src/column/column.rs
index 61b82aa..183e493 100644
--- a/src/column/column.rs
+++ b/src/column/column.rs
@@ -1,4 +1,4 @@
-use crate::{bitmap::*, ColumnIndex};
+use crate::{bitmap::*, ColumnIndex, ColumnU8};
 use core::any::Any;
 use std::{any::TypeId, ops::Deref};

@@ -61,14 +61,13 @@ impl<'a> ColumnWrapper<'a> {

     pub fn new_ref<T, V>(col: &'a V, index: Option<Vec<usize>>, bitmap: Option<Bitmap>) -> Self
     where
-        V: Deref<Target = [T]>,
         V: Send + Sync + 'static,
+        V: Deref<Target = [T]>,
     {
         //Validate that the bitmap and the data have the same length
         bitmap
             .iter()
             .for_each(|b| assert_eq!((*col).len(), b.len()));
-
         let typeid = TypeId::of::<V>();
         let typename = std::any::type_name::<V>();
         Self {
@@ -87,8 +86,8 @@ impl<'a> ColumnWrapper<'a> {
         bitmap: Option<Bitmap>,
     ) -> Self
     where
-        V: Deref<Target = [T]>,
         V: Send + Sync + 'static,
+        V: Deref<Target = [T]>,
     {
         //Validate that the bitmap and the data have the same length
         bitmap
@@ -106,6 +105,29 @@ impl<'a> ColumnWrapper<'a> {
             name: None,
         }
     }
+
+    pub fn new_ref_u8(
+        col: &'a ColumnU8,
+        index: Option<Vec<usize>>,
+        bitmap: Option<Bitmap>,
+    ) -> Self {
+        //Validate that the bitmap and the data have the same length
+        bitmap
+            .iter()
+            .for_each(|b| assert_eq!((*col).len.len(), b.len()));
+
+        let typeid = TypeId::of::<ColumnU8>();
+        let typename = std::any::type_name::<ColumnU8>();
+        Self {
+            column: ColumnData::Ref(col),
+            index,
+            bitmap,
+            typeid,
+            typename: typename.to_string(),
+            name: None,
+        }
+    }
+
     pub fn with_name(mut self, name: &str) -> Self {
         self.name = Some(name.to_string());
         self
diff --git a/src/columnpartition.rs b/src/columnpartition.rs
index a8e6336..067c5f1 100644
--- a/src/columnpartition.rs
+++ b/src/columnpartition.rs
@@ -12,7 +12,12 @@ use crate::hashcolumn::*;
 pub trait ColumnPartition<V, T> {
     fn get_col(&self) -> &V;
     fn get_col_mut(&mut self) -> &mut V;
-    fn hash_column<S>(&self, index: &ColumnIndex, bitmap: &Option<Bitmap>, s: &S) -> HashColumn
+    fn hash_column<'a, S>(
+        &self,
+        index: &ColumnIndex,
+        bitmap: &Option<Bitmap>,
+        s: &S,
+    ) -> HashColumn<'a>
     where
         S: BuildHasher + Sync,
         V: Deref<Target = [T]>,
diff --git a/src/expressions/initdictionary.rs b/src/expressions/initdictionary.rs
index 2520059..a7d0bbc 100644
--- a/src/expressions/initdictionary.rs
+++ b/src/expressions/initdictionary.rs
@@ -35,7 +35,7 @@ macro_rules! binary_operation_impl {

 binary_operation_impl! {

-u64 u32 u16 u8 bool
+u64 u32 u16 u8 bool usize

 }

@@ -47,7 +47,7 @@ pub fn load_init_dict(init_dict: &mut InitDictionary) {
     //dict.insert(s, columnadd_onwedcolumnvecu64_vecu64);7
     binary_operation_load! {init_dict;

-        u64 u32 u16 u8 bool
+        u64 u32 u16 u8 bool usize

     };
 }
diff --git a/src/expressions/operations/addinit.rs b/src/expressions/operations/addinit.rs
index 85d3ed1..019d4c1 100644
--- a/src/expressions/operations/addinit.rs
+++ b/src/expressions/operations/addinit.rs
@@ -192,12 +192,12 @@ macro_rules! operation_impl {
 }

 operation_impl! {
-    (u64, u64) (u64, u32) (u64, u16) (u64, u8) (u64, bool) (u32,u32)
+    (u64, u64) (u64, u32) (u64, u16) (u64, u8) (u64, bool) (u32,u32) (usize, usize)
 }

 pub(crate) fn load_op_dict(dict: &mut OpDictionary) {
     //dict.insert(s, columnadd_onwedcolumnvecu64_vecu64);7
     operation_load! {dict;
-            (u64, u64) (u64, u32) (u64, u16) (u64, u8) (u64, bool) (u32,u32)
+            (u64, u64) (u64, u32) (u64, u16) (u64, u8) (u64, bool) (u32,u32) (usize, usize)
     };
 }
diff --git a/src/expressions/operations/eqinit.rs b/src/expressions/operations/eqinit.rs
index 511915f..941d6f5 100644
--- a/src/expressions/operations/eqinit.rs
+++ b/src/expressions/operations/eqinit.rs
@@ -113,12 +113,12 @@ macro_rules! operation_impl {
                     },
                     (None, Some(ind_rhs), None)=>{
                         data_output.extend(
-                            data_input_lhs.iter().zip(ind_rhs.iter()).map(|(lv, ri)| (*lv).eq(&T1::from(data_input_lhs[*ri])))
+                            data_input_lhs.iter().zip(ind_rhs.iter()).map(|(lv, ri)| (*lv).eq(&T1::from(data_input_rhs[*ri])))
                         );
                     },
                     (Some(ind_lhs), Some(ind_rhs), None)=>{
                         data_output.extend(
-                            ind_lhs.iter().zip(ind_rhs.iter()).map(|(li, ri)| (data_input_lhs[*li]).eq(&T1::from(data_input_lhs[*ri])))
+                            ind_lhs.iter().zip(ind_rhs.iter()).map(|(li, ri)| (data_input_lhs[*li]).eq(&T1::from(data_input_rhs[*ri])))
                         );
                     },

@@ -157,7 +157,7 @@ macro_rules! operation_impl {
                             .zip(bits.iter())
                             .map(|((lv, ri),b)|
                                 if *b!=0 {
-                                    (*lv).eq(&T1::from(data_input_lhs[*ri]))
+                                    (*lv).eq(&T1::from(data_input_rhs[*ri]))
                                 } else {Default::default()}
                         )
                         );
@@ -170,7 +170,7 @@ macro_rules! operation_impl {
                             .zip(bits.iter())
                             .map(|((li, ri),b)|
                                 if *b!=0 {
-                                    (data_input_lhs[*li]).eq(&T1::from(data_input_lhs[*ri]))
+                                    (data_input_lhs[*li]).eq(&T1::from(data_input_rhs[*ri]))
                                 } else {Default::default()}
                             )
                         );
@@ -190,12 +190,12 @@ macro_rules! operation_impl {
 }

 operation_impl! {
-    (u64, u64) (u64, u32) (u64, u16) (u64, u8) (u64, bool) (u32,u32)
+    (u64, u64) (u64, u32) (u64, u16) (u64, u8) (u64, bool) (u32,u32) (usize, usize)
 }

 pub(crate) fn load_op_dict(dict: &mut OpDictionary) {
     //dict.insert(s, columnadd_onwedcolumnvecu64_vecu64);7
     operation_load! {dict;
-            (u64, u64) (u64, u32) (u64, u16) (u64, u8) (u64, bool) (u32,u32)
+            (u64, u64) (u64, u32) (u64, u16) (u64, u8) (u64, bool) (u32,u32) (usize, usize)
     };
 }
diff --git a/src/expressions/operations/gteqinit.rs b/src/expressions/operations/gteqinit.rs
index a2dd4ec..87140d1 100644
--- a/src/expressions/operations/gteqinit.rs
+++ b/src/expressions/operations/gteqinit.rs
@@ -113,12 +113,12 @@ macro_rules! operation_impl {
                     },
                     (None, Some(ind_rhs), None)=>{
                         data_output.extend(
-                            data_input_lhs.iter().zip(ind_rhs.iter()).map(|(lv, ri)| (*lv).ge(&T1::from(data_input_lhs[*ri])))
+                            data_input_lhs.iter().zip(ind_rhs.iter()).map(|(lv, ri)| (*lv).ge(&T1::from(data_input_rhs[*ri])))
                         );
                     },
                     (Some(ind_lhs), Some(ind_rhs), None)=>{
                         data_output.extend(
-                            ind_lhs.iter().zip(ind_rhs.iter()).map(|(li, ri)| (data_input_lhs[*li]).ge(&T1::from(data_input_lhs[*ri])))
+                            ind_lhs.iter().zip(ind_rhs.iter()).map(|(li, ri)| (data_input_lhs[*li]).ge(&T1::from(data_input_rhs[*ri])))
                         );
                     },

@@ -157,7 +157,7 @@ macro_rules! operation_impl {
                             .zip(bits.iter())
                             .map(|((lv, ri),b)|
                                 if *b!=0 {
-                                    (*lv).ge(&T1::from(data_input_lhs[*ri]))
+                                    (*lv).ge(&T1::from(data_input_rhs[*ri]))
                                 } else {Default::default()}
                         )
                         );
@@ -170,7 +170,7 @@ macro_rules! operation_impl {
                             .zip(bits.iter())
                             .map(|((li, ri),b)|
                                 if *b!=0 {
-                                    (data_input_lhs[*li]).ge(&T1::from(data_input_lhs[*ri]))
+                                    (data_input_lhs[*li]).ge(&T1::from(data_input_rhs[*ri]))
                                 } else {Default::default()}
                             )
                         );
@@ -190,12 +190,12 @@ macro_rules! operation_impl {
 }

 operation_impl! {
-    (u64, u64) (u64, u32) (u64, u16) (u64, u8) (u64, bool) (u32,u32)
+    (u64, u64) (u64, u32) (u64, u16) (u64, u8) (u64, bool) (u32,u32) (usize, usize)
 }

 pub(crate) fn load_op_dict(dict: &mut OpDictionary) {
     //dict.insert(s, columnadd_onwedcolumnvecu64_vecu64);7
     operation_load! {dict;
-            (u64, u64) (u64, u32) (u64, u16) (u64, u8) (u64, bool) (u32,u32)
+            (u64, u64) (u64, u32) (u64, u16) (u64, u8) (u64, bool) (u32,u32) (usize, usize)
     };
 }
diff --git a/src/expressions/operations/hash.rs b/src/expressions/operations/hash.rs
index 4820003..20d9d2c 100644
--- a/src/expressions/operations/hash.rs
+++ b/src/expressions/operations/hash.rs
@@ -128,7 +128,7 @@ macro_rules! binary_operation_impl {

 binary_operation_impl! {

-u64 u32 u16 u8 bool
+u64 u32 u16 u8 bool usize

 }

@@ -140,7 +140,6 @@ pub(crate) fn load_op_dict(dict: &mut OpDictionary) {
     //dict.insert(s, columnadd_onwedcolumnvecu64_vecu64);7
     binary_operation_load! {dict;

-        u64 u32 u16 u8 bool
-
+        u64 u32 u16 u8 bool usize
     };
 }
diff --git a/src/expressions/operations/hashinit.rs b/src/expressions/operations/hashinit.rs
index f795700..86987a0 100644
--- a/src/expressions/operations/hashinit.rs
+++ b/src/expressions/operations/hashinit.rs
@@ -106,7 +106,7 @@ macro_rules! binary_operation_impl {

 binary_operation_impl! {

-u64 u32 u16 u8 bool
+u64 u32 u16 u8 bool usize

 }

@@ -118,7 +118,7 @@ pub(crate) fn load_op_dict(dict: &mut OpDictionary) {
     //dict.insert(s, columnadd_onwedcolumnvecu64_vecu64);7
     binary_operation_load! {dict;

-        u64 u32 u16 u8 bool
+        u64 u32 u16 u8 bool usize

     };
 }
diff --git a/src/expressions/operations/mod.rs b/src/expressions/operations/mod.rs
index 2601460..fc38c0a 100644
--- a/src/expressions/operations/mod.rs
+++ b/src/expressions/operations/mod.rs
@@ -3,7 +3,9 @@ use crate::expressions::opdictionary::OpDictionary;
 pub mod addassign;
 pub mod addinit;
 pub mod eqinit;
+pub mod eqinitu8;
 pub mod gteqinit;
+pub mod gtinit;
 pub mod hash;
 pub mod hashinit;
 pub mod hashu8;
@@ -17,5 +19,7 @@ pub fn load_op_dict(dict: &mut OpDictionary) {
     hashu8::load_op_dict(dict);
     addinit::load_op_dict(dict);
     eqinit::load_op_dict(dict);
+    eqinitu8::load_op_dict(dict);
     gteqinit::load_op_dict(dict);
+    gtinit::load_op_dict(dict);
 }
diff --git a/src/hashcolumn.rs b/src/hashcolumn.rs
index ca2b8a5..a7a529e 100644
--- a/src/hashcolumn.rs
+++ b/src/hashcolumn.rs
@@ -10,17 +10,17 @@ use std::{
 pub type HashData = Vec<u64>;

 #[derive(Debug)]
-pub struct HashColumn {
-    pub(crate) data: ColumnWrapper<'static>,
+pub struct HashColumn<'a> {
+    pub(crate) data: ColumnWrapper<'a>,
 }

-impl From<HashColumn> for ColumnWrapper<'static> {
-    fn from(hash: HashColumn) -> Self {
+impl<'a> From<HashColumn<'a>> for ColumnWrapper<'a> {
+    fn from(hash: HashColumn<'a>) -> Self {
         hash.data
     }
 }

-impl<'a> TryFrom<ColumnWrapper<'a>> for HashColumn {
+impl<'a> TryFrom<ColumnWrapper<'a>> for HashColumn<'a> {
     type Error = &'static str;
     fn try_from(c: ColumnWrapper<'a>) -> Result<Self, Self::Error> {
         if c.index().is_some() {
@@ -37,25 +37,31 @@ impl<'a> TryFrom<ColumnWrapper<'a>> for HashColumn {
     }
 }

-impl Deref for HashColumn {
+impl<'a> Deref for HashColumn<'a> {
     type Target = Vec<u64>;
     fn deref(&self) -> &Self::Target {
         self.data.downcast_ref::<HashData>()
     }
 }

-impl DerefMut for HashColumn {
+impl<'a> DerefMut for HashColumn<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         self.data.downcast_mut::<HashData>()
     }
 }

-impl HashColumn {
+impl<'a> HashColumn<'a> {
     pub fn new(data: Vec<u64>, bitmap: Option<Bitmap>) -> Self {
         Self {
             data: ColumnWrapper::new(data, None, bitmap),
         }
     }
+    pub fn new_ref(data: &'a Vec<u64>, bitmap: Option<Bitmap>) -> Self {
+        Self {
+            data: ColumnWrapper::new_ref(data, None, bitmap),
+        }
+    }
+
     pub fn bitmap(&self) -> &Option<Bitmap> {
         self.data.bitmap()
     }
diff --git a/src/lib.rs b/src/lib.rs
index 28fdf36..97e318d 100644
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -20,6 +20,7 @@ pub use columnrepartition::*;
 pub use columnu8::*;
 pub use executor::*;
 pub use expressions::*;
+pub use hashcolumn::*;
 pub use hashjoin::*;
 pub use sql::*;
 //TO-DO: Make library safe (e.g.) safe rust code outside of it can't cause UB
diff --git a/src/sql/projection.rs b/src/sql/projection.rs
index 2eb1a68..b9c9a43 100644
--- a/src/sql/projection.rs
+++ b/src/sql/projection.rs
@@ -6,6 +6,8 @@ fn op_name(op: &BinaryOperator) -> String {
         BinaryOperator::Plus => "+=",
         BinaryOperator::Minus => "-=",
         BinaryOperator::Eq => "===",
+        BinaryOperator::GtEq => ">==",
+        BinaryOperator::Gt => ">==",
         _ => panic!(),
     };
     op_name.to_string()
@@ -16,6 +18,8 @@ fn op_name_init(op: &BinaryOperator) -> String {
         BinaryOperator::Plus => "+",
         BinaryOperator::Minus => "-",
         BinaryOperator::Eq => "==",
+        BinaryOperator::GtEq => ">=",
+        BinaryOperator::Gt => ">",
         _ => panic!(),
     };
     op_name.to_string()
